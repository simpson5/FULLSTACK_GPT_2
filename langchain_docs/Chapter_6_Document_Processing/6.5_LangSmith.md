# 📖 Section 6.5: LangSmith - 체인 모니터링 및 디버깅 플랫폼

## 🎯 학습 목표
- ✅ RAG 애플리케이션에서 체인 관찰성과 디버깅의 중요성 이해
- ✅ 종합적인 체인 모니터링을 위한 LangSmith 설정 방법 학습
- ✅ 복잡한 체인 디버깅을 위한 LangSmith 시각화 도구 마스터
- ✅ 체인 실행 플로우와 성능 지표 분석 실습

## 🧠 핵심 개념

### LangSmith란?
**LangSmith**는 LangChain의 공식 모니터링 및 디버깅 플랫폼으로, LangChain 애플리케이션에 대한 종합적인 관찰성을 제공합니다. 체인 실행의 실시간 시각화, 상세한 로깅, 성능 분석 기능을 제공합니다.

**주요 장점:**
- **완전한 가시성**: 체인 실행의 모든 단계 확인
- **복잡한 플로우 디버깅**: 각 구성 요소를 통한 입출력 추적
- **성능 모니터링**: 실행 시간과 리소스 사용량 추적
- **오류 분석**: 체인 실패를 빠르게 식별하고 진단
- **프로덕션 준비**: 라이브 애플리케이션 모니터링 및 문제 감지

### RAG 애플리케이션에서 LangSmith가 필수인 이유

**RAG 체인 복잡성**: 현대 RAG 애플리케이션은 여러 구성 요소를 포함합니다:
- Vector Store에서 문서 검색
- Prompt template 포맷팅
- LLM 처리
- 응답 생성
- 오류 처리 및 fallback

**관찰성 없는 디버깅의 어려움**:
```python
# LangSmith 없이 - 디버깅이 어려움
chain = retriever | prompt | llm
result = chain.invoke("프랑스의 수도는 어디인가요?")
# ❌ 결과가 틀렸다면, 어디서 문제가 발생했을까?
# ❌ 검색이 실패했나? 프롬프트가 잘못 구성되었나?
# ❌ LLM이 컨텍스트를 오해했나?
```

**LangSmith와 함께 - 완전한 가시성**:
```python
# LangSmith와 함께 - 모든 단계가 추적 가능
chain = retriever | prompt | llm
result = chain.invoke("프랑스의 수도는 어디인가요?")
# ✅ 검색된 문서를 실시간으로 확인
# ✅ LLM 처리 전 포맷된 프롬프트 확인
# ✅ 토큰 사용량과 응답 시간 추적
# ✅ 정확한 실패 지점 식별
```

## 🔧 설정 가이드

### 1단계: LangSmith 가입
1. **LangSmith 방문**: [langchain.com/langsmith](https://langchain.com/langsmith)로 이동
2. **회원가입**: 이메일로 계정 생성
3. **대기 목록**: 베타 대기 목록 등록 (베타 중인 경우)
4. **초대**: 이메일로 초대 코드 대기
5. **계정 활성화**: 계정 설정 완료

**현재 상태 확인**:
```python
def check_langsmith_status():
    """LangSmith 접근 가능 여부 확인"""
    import requests
    
    try:
        response = requests.get("https://smith.langchain.com/", timeout=5)
        if response.status_code == 200:
            print("✅ LangSmith 접근 가능")
            return True
        else:
            print("⚠️ LangSmith 초대 필요할 수 있음")
            return False
    except:
        print("❌ LangSmith에 연결할 수 없음")
        return False

# 현재 상태 확인
check_langsmith_status()
```

### 2단계: API 키 생성
1. **LangSmith 로그인**: LangSmith 대시보드 접근
2. **설정으로 이동**: API 키 관리 섹션 찾기
3. **새 키 생성**: 새로운 API 키 생성
4. **키 복사**: 생성된 키 안전하게 복사
5. **안전한 저장**: 환경 설정을 위해 키를 안전하게 보관

### 3단계: 환경 설정
**필수 환경 변수**:
```bash
# .env 파일에 추가
LANGCHAIN_TRACING_V2=true
LANGCHAIN_ENDPOINT=https://api.smith.langchain.com
LANGCHAIN_API_KEY=your_api_key_here
LANGCHAIN_PROJECT=your_project_name  # 선택사항: 커스텀 프로젝트 이름
```

**완전한 .env 파일 예시**:
```bash
# OpenAI 설정
OPENAI_API_KEY=sk-your-openai-key-here

# LangSmith 설정
LANGCHAIN_TRACING_V2=true
LANGCHAIN_ENDPOINT=https://api.smith.langchain.com
LANGCHAIN_API_KEY=ls_your-langsmith-key-here
LANGCHAIN_PROJECT=RAG_문서_처리

# 기타 설정
VECTOR_STORE_PATH=./chroma_db
MODEL_NAME=gpt-3.5-turbo
```

### 4단계: 설정 확인
```python
import os
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate

def verify_langsmith_setup():
    """LangSmith 설정이 작동하는지 확인"""
    
    # 환경 변수 확인
    required_vars = [
        'LANGCHAIN_TRACING_V2',
        'LANGCHAIN_ENDPOINT', 
        'LANGCHAIN_API_KEY'
    ]
    
    print("🔧 LangSmith 설정 확인:")
    print("=" * 50)
    
    missing_vars = []
    for var in required_vars:
        value = os.getenv(var)
        if value:
            # 보안을 위해 실제 API 키는 표시하지 않음
            display_value = value if var != 'LANGCHAIN_API_KEY' else 'ls_****'
            print(f"✅ {var}: {display_value}")
        else:
            missing_vars.append(var)
            print(f"❌ {var}: 누락됨")
    
    if missing_vars:
        print(f"\n⚠️ 누락된 변수: {missing_vars}")
        print(".env 파일에 추가하고 환경을 재시작하세요")
        return False
    
    # 간단한 체인으로 테스트
    print(f"\n🧪 LangSmith 통합 테스트:")
    try:
        llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0)
        prompt = ChatPromptTemplate.from_messages([
            ("human", "안녕하세요, 이것은 LangSmith 테스트입니다. 'LangSmith가 작동합니다!'라고 응답해주세요")
        ])
        
        chain = prompt | llm
        response = chain.invoke({})
        
        print(f"✅ 테스트 성공: {response.content}")
        print(f"✅ LangSmith 대시보드에서 추적 세부사항을 확인하세요")
        return True
        
    except Exception as e:
        print(f"❌ 테스트 실패: {e}")
        return False

# 확인 실행
verify_langsmith_setup()
```

## 📊 LangSmith 대시보드 개요

### 메인 대시보드 기능

**1. 프로젝트 개요**
```python
def create_langsmith_project():
    """LangSmith 프로젝트 생성 및 설정"""
    
    # 프로젝트는 서로 다른 애플리케이션/실험을 구성하는 데 도움
    project_config = {
        "name": "RAG_문서_처리",
        "description": "6장 - 문서 처리 및 검색 체인",
        "tags": ["RAG", "문서처리", "교육"],
        "metadata": {
            "course": "FULLSTACK_GPT",
            "chapter": 6,
            "focus": "Retrieval Augmented Generation"
        }
    }
    
    # 환경 변수를 통해 프로젝트 설정
    os.environ['LANGCHAIN_PROJECT'] = project_config['name']
    
    return project_config

# 프로젝트 설정
project_info = create_langsmith_project()
print(f"📊 LangSmith 프로젝트: {project_info['name']}")
```

**2. 추적 시각화**
- **계층적 뷰**: 체인 구성 요소 간 부모-자식 관계 확인
- **타임라인 뷰**: 실행 순서와 타이밍 이해
- **입출력 검사**: 각 단계에서의 데이터 흐름 검토
- **오류 강조**: 실패 지점을 빠르게 식별

**3. 성능 지표**
- **실행 시간**: 전체 및 구성 요소별 타이밍
- **토큰 사용량**: 입력 및 출력 토큰 소비
- **비용 추적**: 실행별 API 비용 모니터링
- **성공률**: 성공/실패 비율 추적

### LangSmith 추적 해석

**예시: Stuff Chain 추적 분석**
```python
def analyze_stuff_chain_trace():
    """LangSmith 추적에서 찾아봐야 할 것들의 예시"""
    
    trace_analysis = {
        "RunnableParallel": {
            "description": "retriever와 passthrough의 병렬 실행",
            "what_to_check": [
                "두 구성 요소가 병렬로 실행되고 있는가?",
                "retriever가 관련 문서를 반환하고 있는가?",
                "passthrough가 원본 질문을 보존하고 있는가?"
            ],
            "common_issues": [
                "병렬 실행 대신 순차 실행",
                "빈 문서 검색",
                "질문 수정 또는 손실"
            ]
        },
        
        "Retriever": {
            "description": "Vector Store에서 문서 검색",
            "what_to_check": [
                "검색된 문서 수",
                "관련성 점수 (가능한 경우)",
                "문서 내용 품질",
                "검색 실행 시간"
            ],
            "common_issues": [
                "문서를 찾지 못함",
                "관련 없는 문서 검색", 
                "느린 검색 성능",
                "Vector Store 연결 오류"
            ]
        },
        
        "ChatPromptTemplate": {
            "description": "컨텍스트와 질문으로 프롬프트 포맷팅",
            "what_to_check": [
                "적절한 컨텍스트 주입",
                "질문 배치",
                "템플릿 변수 치환",
                "최종 프롬프트 구조"
            ],
            "common_issues": [
                "컨텍스트 또는 질문 누락",
                "템플릿 변수 오류",
                "모델 컨텍스트에 대해 프롬프트가 너무 김",
                "잘못된 메시지 구조"
            ]
        },
        
        "ChatOpenAI": {
            "description": "LLM 처리 및 응답 생성",
            "what_to_check": [
                "입력 토큰 수",
                "출력 토큰 수",
                "응답 품질",
                "처리 시간"
            ],
            "common_issues": [
                "컨텍스트 길이 초과",
                "예상치 못한 응답 형식",
                "높은 지연 시간",
                "API 속도 제한"
            ]
        }
    }
    
    return trace_analysis

# 분석 가이드라인 가져오기
guidelines = analyze_stuff_chain_trace()
for component, info in guidelines.items():
    print(f"\n🔍 {component}:")
    print(f"   📝 {info['description']}")
    print(f"   ✅ 확인사항: {info['what_to_check'][0]}")
    print(f"   ⚠️  문제점: {info['common_issues'][0]}")
```

## 💻 실전 예제

### 예제 1: 기본 체인 모니터링
```python
from langchain_openai import ChatOpenAI
from langchain.prompts import ChatPromptTemplate
from langchain_community.vectorstores import Chroma
from langchain_openai import OpenAIEmbeddings
from langchain_core.runnables import RunnablePassthrough
import time

def create_monitored_basic_chain():
    """LangSmith 모니터링이 있는 기본 체인 생성"""
    
    print("🔗 모니터링된 기본 체인 생성:")
    print("=" * 50)
    
    # 구성 요소 초기화
    llm = ChatOpenAI(
        model="gpt-3.5-turbo",
        temperature=0.1,
        model_kwargs={"seed": 42}  # 재현 가능한 결과를 위해
    )
    
    # 기존 Vector Store 로드
    embeddings = OpenAIEmbeddings()
    vector_store = Chroma(
        persist_directory="./chroma_db",
        embedding_function=embeddings
    )
    retriever = vector_store.as_retriever(search_kwargs={"k": 3})
    
    # 프롬프트 템플릿 생성
    prompt = ChatPromptTemplate.from_messages([
        ("system", """당신은 도움이 되는 AI 어시스턴트입니다.
        제공된 컨텍스트를 바탕으로 정확한 답변을 해주세요.
        
        컨텍스트:
        {context}"""),
        ("human", "{question}")
    ])
    
    # 모니터링된 체인 생성
    chain = (
        {
            "context": retriever,
            "question": RunnablePassthrough()
        }
        | prompt 
        | llm
    )
    
    return chain

def test_monitored_chain():
    """다양한 유형의 질문으로 체인 테스트"""
    
    chain = create_monitored_basic_chain()
    
    test_cases = [
        {
            "question": "Winston Smith는 어디에 살고 있나요?",
            "category": "factual_simple",
            "expected_trace_pattern": "retriever → prompt → llm"
        },
        {
            "question": "1984년 소설에서 가장 중요한 주제는 무엇인가요?", 
            "category": "analytical_complex",
            "expected_trace_pattern": "retriever → prompt → llm"
        },
        {
            "question": "존재하지 않는 등장인물에 대해 알려주세요",
            "category": "no_context_available",
            "expected_trace_pattern": "retriever → prompt → llm (빈 컨텍스트)"
        }
    ]
    
    print(f"\n🧪 LangSmith 모니터링으로 체인 테스트:")
    print("=" * 60)
    
    for i, test_case in enumerate(test_cases, 1):
        print(f"\n📋 테스트 {i}: {test_case['category']}")
        print(f"❓ 질문: {test_case['question']}")
        print(f"🔍 예상 패턴: {test_case['expected_trace_pattern']}")
        
        try:
            start_time = time.time()
            
            # 자동으로 LangSmith에서 추적 생성
            response = chain.invoke(test_case['question'])
            
            execution_time = time.time() - start_time
            
            print(f"✅ 응답: {response.content[:100]}...")
            print(f"⏱️ 시간: {execution_time:.2f}초")
            print(f"📊 자세한 추적은 LangSmith에서 확인")
            
        except Exception as e:
            print(f"❌ 오류: {e}")
    
    print(f"\n💡 다음 단계:")
    print(f"   1. LangSmith 대시보드 열기")
    print(f"   2. 프로젝트로 이동: {os.getenv('LANGCHAIN_PROJECT', 'default')}")
    print(f"   3. 각 테스트 케이스의 추적 검토")
    print(f"   4. 입출력 흐름과 성능 분석")

# 테스트 실행
test_monitored_chain()
```

### 예제 2: 커스텀 메타데이터가 있는 고급 체인
```python
from langchain.callbacks import LangChainTracer
from typing import Any, Dict
import uuid

def create_advanced_monitored_chain():
    """커스텀 메타데이터와 태그가 있는 체인 생성"""
    
    def enhanced_retrieval_with_metadata(query: str) -> str:
        """커스텀 메타데이터가 있는 검색 함수"""
        
        # 추적에 커스텀 메타데이터 추가
        metadata = {
            "query_length": len(query),
            "query_complexity": "high" if len(query.split()) > 10 else "low",
            "timestamp": time.time(),
            "retrieval_strategy": "similarity_search"
        }
        
        # 검색 수행
        docs = retriever.get_relevant_documents(query)
        
        # 메타데이터로 문서 포맷
        formatted_docs = []
        for i, doc in enumerate(docs, 1):
            doc_metadata = {
                "doc_index": i,
                "content_length": len(doc.page_content),
                "source": doc.metadata.get('source', 'unknown')
            }
            
            content = doc.page_content.strip()
            if len(content) > 400:
                content = content[:400] + "..."
            
            formatted_docs.append(f"[문서 {i}]\n{content}")
        
        result = "\n\n".join(formatted_docs) if formatted_docs else "관련 문서를 찾을 수 없습니다."
        
        return result
    
    # 커스텀 구성 요소가 있는 체인 생성
    enhanced_chain = (
        {
            "context": RunnableLambda(enhanced_retrieval_with_metadata),
            "question": RunnablePassthrough()
        }
        | prompt
        | llm
    )
    
    return enhanced_chain

def run_chain_with_custom_metadata():
    """커스텀 메타데이터와 세션 추적으로 체인 실행"""
    
    chain = create_advanced_monitored_chain()
    
    # 관련 쿼리를 그룹화하기 위한 커스텀 세션 ID
    session_id = f"session_{uuid.uuid4().hex[:8]}"
    
    queries_with_context = [
        {
            "query": "Winston Smith의 일상 생활은 어떤가요?",
            "context": "character_analysis",
            "priority": "high"
        },
        {
            "query": "Victory Mansions의 특징을 설명해주세요",
            "context": "setting_description", 
            "priority": "medium"
        },
        {
            "query": "소설 1984의 주요 갈등은 무엇인가요?",
            "context": "thematic_analysis",
            "priority": "high"
        }
    ]
    
    print(f"\n🎯 커스텀 메타데이터로 고급 체인 실행:")
    print(f"📝 세션 ID: {session_id}")
    print("=" * 60)
    
    for i, query_info in enumerate(queries_with_context, 1):
        print(f"\n📋 쿼리 {i}: {query_info['context']}")
        print(f"❓ 질문: {query_info['query']}")
        print(f"🔢 우선순위: {query_info['priority']}")
        
        # 메타데이터가 있는 커스텀 설정
        config = {
            "metadata": {
                "session_id": session_id,
                "query_number": i,
                "query_context": query_info['context'],
                "priority": query_info['priority'],
                "user_type": "student",
                "course_chapter": 6
            },
            "tags": [
                f"chapter_6",
                f"{query_info['context']}", 
                f"priority_{query_info['priority']}"
            ]
        }
        
        try:
            start_time = time.time()
            
            response = chain.invoke(
                query_info['query'],
                config=config
            )
            
            execution_time = time.time() - start_time
            
            print(f"✅ 응답: {response.content[:80]}...")
            print(f"⏱️ 시간: {execution_time:.2f}초")
            print(f"🏷️ 태그: {config['tags']}")
            
        except Exception as e:
            print(f"❌ 오류: {e}")
    
    print(f"\n📊 LangSmith 분석 팁:")
    print(f"   • session_id로 필터링: {session_id}")
    print(f"   • 패턴 분석을 위해 query_context로 그룹화")
    print(f"   • 높은 우선순위 vs 중간 우선순위 쿼리 성능 비교")
    print(f"   • 유사한 컨텍스트 전반의 일관된 패턴 확인")

# 고급 모니터링 실행
run_chain_with_custom_metadata()
```

## 📋 LangSmith 모범 사례

### 1. 효과적인 프로젝트 구성
```python
def setup_langsmith_best_practices():
    """모범 사례에 따른 LangSmith 설정"""
    
    best_practices = {
        "project_naming": {
            "pattern": "service_environment_version",
            "examples": [
                "rag_production_v1",
                "document_processing_staging_v2",
                "chatbot_development_v1"
            ]
        },
        
        "metadata_standards": {
            "required_fields": [
                "session_id",
                "user_id", 
                "request_type",
                "timestamp"
            ],
            "recommended_fields": [
                "model_version",
                "environment",
                "feature_flags",
                "user_segment"
            ]
        },
        
        "tagging_strategy": {
            "hierarchical": [
                "environment:production",
                "service:rag",
                "component:retrieval",
                "version:1.0"
            ],
            "functional": [
                "user_facing",
                "batch_processing",
                "real_time",
                "experimental"
            ]
        }
    }
    
    return best_practices

# 모범 사례 가이드 가져오기
practices = setup_langsmith_best_practices()
print("📋 LangSmith 모범 사례:")
for category, details in practices.items():
    print(f"\n🔧 {category.replace('_', ' ').title()}:")
    if isinstance(details, dict):
        for key, value in details.items():
            print(f"   {key}: {value}")
    else:
        for item in details:
            print(f"   • {item}")
```

## ⚠️ 주의사항

⚠️ **API 키 보안**: LangSmith API 키를 버전 관리에 커밋하지 마세요. 환경 변수와 보안 설정 관리를 사용하세요.

⚠️ **데이터 프라이버시**: 추적에는 프롬프트와 응답이 포함됩니다. 민감한 데이터가 적절히 처리되는지 확인하세요.

⚠️ **비용 관리**: LangSmith 추적이 비용을 누적할 수 있습니다. 사용량을 모니터링하고 적절한 보존 정책을 설정하세요.

⚠️ **네트워크 의존성**: 신뢰할 수 있는 추적 전송을 위해 안정적인 인터넷 연결이 필요합니다. 오프라인 시나리오에 대한 fallback 메커니즘을 구현하세요.

## 🧪 실습 과제

### 🔨 기본 과제
1. **기본 LangSmith 설정**
   - LangSmith 계정 가입
   - 환경 변수 설정
   - 간단한 체인으로 테스트
   - 대시보드에서 첫 번째 추적 분석

2. **추적 분석 연습**
   - 여러 체인 변형 생성 (다른 retriever, 프롬프트)
   - 다른 체인에서 동일한 쿼리 실행
   - 추적을 비교하여 성능 차이 식별
   - 발견 사항과 최적화 권장사항 문서화

### 🚀 심화 과제
3. **오류 시나리오 테스트**
   - 특정 조건에서 의도적으로 실패하는 체인 설계
   - 종합적인 오류 테스트 케이스 생성
   - LangSmith에서 오류 추적 분석
   - 추적 인사이트를 기반으로 견고한 오류 처리 구현

4. **프로덕션 모니터링 설정**
   - 프로덕션 준비 모니터링 설정 생성
   - 커스텀 메타데이터 및 태그 전략 구현
   - 성능 알림 임계값 설정
   - LangSmith 데이터에서 자동 리포팅 구축

### 💡 창의 과제
5. **실시간 대시보드 구축**
   - LangSmith API를 사용한 커스텀 대시보드 생성
   - 실시간 성능 지표 시각화
   - 알림 및 경고 시스템 구현

## 🔗 관련 자료
- **이전 학습**: [6.4 Vector Stores](./6.4_Vector_Stores.md)
- **다음 학습**: [6.6 RetrievalQA](./6.6_RetrievalQA.md)
- **LangSmith 문서**: [공식 LangSmith 문서](https://docs.smith.langchain.com/)
- **설정 가이드**: [LangSmith 빠른 시작](https://docs.smith.langchain.com/getting-started)

---

💡 **핵심 정리**: LangSmith는 RAG 애플리케이션에 필수적인 관찰성을 제공하여, 개발자가 전례 없는 가시성으로 체인을 이해하고, 디버깅하고, 최적화할 수 있게 합니다. 복잡한 체인 디버깅을 블랙박스에서 투명하고 분석 가능한 프로세스로 변환합니다.